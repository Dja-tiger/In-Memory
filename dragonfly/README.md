# Примеры Dragonfly

## Обзор
Dragonfly - это современное хранилище данных в памяти, полностью совместимое с API Redis, но разработанное для требований современных приложений. Обеспечивает 25-кратную пропускную способность Redis благодаря использованию многопоточной архитектуры без разделения ресурсов.

## Ключевые особенности
- **25× производительность Redis** - Масштабируется вертикально с ядрами процессора
- **Совместимость с Redis API** - Прямая замена Redis
- **Эффективность памяти** - На 30% меньше использования памяти, чем Redis
- **Многопоточность** - Использует все доступные ядра процессора
- **Согласованные снимки** - Неблокирующая персистентность

## Предварительные требования
- Docker
- Python 3.6+
- Клиентские библиотеки Redis (работают с Dragonfly)

## Быстрый старт
```bash
./run.sh
```

## Ручная настройка

### 1. Запуск Dragonfly
```bash
# Используя Docker (рекомендуется)
docker run -d -p 6379:6379 \
    --ulimit memlock=-1 \
    docker.dragonflydb.io/dragonflydb/dragonfly

# С пользовательскими флагами
docker run -d -p 6379:6379 \
    --ulimit memlock=-1 \
    docker.dragonflydb.io/dragonflydb/dragonfly \
    --cache_mode=true \
    --keys_output_limit=12288
```

### 2. Установка зависимостей Python
```bash
# Использует стандартный клиент Redis
pip install redis
```

### 3. Запуск примера
```bash
python3 example.py
```

## Протокол Dragonfly (RESP - Совместимый с Redis)

Dragonfly использует тот же протокол RESP, что и Redis:

```bash
telnet localhost 6379
```

### Основные операции (Такие же как Redis)
```bash
# Все команды Redis работают
SET key value
GET key
HSET hash field value
LPUSH list value
SADD set member
ZADD zset 100 member
```

## Сравнение производительности

### Результаты бенчмарков
```bash
# Однопоточный Redis
redis-benchmark -t set,get -n 1000000
SET: 140,000 ops/sec
GET: 145,000 ops/sec

# Многопоточный Dragonfly (8 ядер)
dragonfly-benchmark -t set,get -n 1000000
SET: 3,500,000 ops/sec  (25× быстрее)
GET: 3,800,000 ops/sec  (26× быстрее)
```

### Использование памяти
```bash
# Хранение 1M ключей с 1KB значениями
Redis:    ~1.4 GB
Dragonfly: ~980 MB (на 30% меньше)
```

## Преимущества архитектуры

### 1. Вертикальное масштабирование
```bash
# Dragonfly автоматически использует все ядра
# Не требуется настройка кластера для использования многоядерности

# Проверка использования процессора
docker stats dragonfly-demo
# Показывает: 400-800% CPU (использует несколько ядер)
```

### 2. Архитектура без разделения ресурсов
- Каждый поток владеет своими данными
- Нет накладных расходов на блокировки или синхронизацию
- Линейная масштабируемость с ядрами

### 3. Современное управление памятью
- Пользовательский аллокатор памяти
- Dashtable вместо dict
- Лучшая локальность кэша
- Сжатые структуры данных

## Расширенные возможности

### Режим кэширования
```bash
# Включить режим кэша для автоматического вытеснения
docker run -d -p 6379:6379 \
    docker.dragonflydb.io/dragonflydb/dragonfly \
    --cache_mode=true
```

### Персистентность
```bash
# Сохранить снимок
SAVE

# Настроить автосохранение
CONFIG SET save "900 1 300 10"

# Проверить последнее сохранение
LASTSAVE
```

### Мониторинг
```bash
# Информация о сервере
INFO server

# Статистика памяти
INFO memory

# Метрики производительности
INFO stats

# Специфичные для Dragonfly метрики
INFO dragonfly
```

## Варианты использования

### 1. Хранилище сессий
```python
# Может обрабатывать миллионы сессий
r.setex(f"session:{session_id}", 3600, session_data)
```

### 2. Аналитика в реальном времени
```python
# Счётчики с высокой пропускной способностью
r.incrby(f"counter:{metric}", value)
r.hincrby(f"stats:{date}", field, delta)
```

### 3. Игровые таблицы лидеров
```python
# Масштабируется до миллионов игроков
r.zadd("leaderboard", {player_id: score})
top_players = r.zrevrange("leaderboard", 0, 99, withscores=True)
```

### 4. Слой кэширования
```python
# Обрабатывает массивные нагрузки чтения
cached = r.get(cache_key)
if not cached:
    data = expensive_operation()
    r.setex(cache_key, 300, data)
```

## Миграция с Redis

### Без изменений кода
```python
# Код Redis
import redis
r = redis.Redis(host='redis-server', port=6379)

# Dragonfly (идентично!)
import redis
r = redis.Redis(host='dragonfly-server', port=6379)
```

### Миграция данных
```bash
# Вариант 1: Репликация
# Установить Dragonfly как реплику Redis
REPLICAOF redis-host 6379

# После синхронизации, повысить до основного
REPLICAOF NO ONE

# Вариант 2: Снимок RDB
# Скопировать dump.rdb Redis в директорию данных Dragonfly
# Dragonfly загрузит его при запуске
```

## Конфигурация

### Важные настройки
```bash
# Максимальная память (автоопределение по умолчанию)
--maxmemory 8gb

# Режим кэша (LRU вытеснение)
--cache_mode=true

# Количество потоков (автоопределение ядер процессора)
--proactor_threads=8

# Расположение снимков
--dir /data

# Уровень логирования
--logtostderr --log_level=info
```

## Бенчмаркинг

### Использование memtier_benchmark
```bash
# Установить memtier
apt-get install memtier-benchmark

# Запустить бенчмарк
memtier_benchmark \
    -s localhost -p 6379 \
    -c 50 -t 4 \
    --pipeline=10 \
    --key-pattern=P:P \
    --key-minimum=1 \
    --key-maximum=1000000 \
    --test-time=60
```

### Ожидаемые результаты (8-ядерная машина)
- SET: 3-4M ops/sec
- GET: 4-5M ops/sec
- Задержка p50: <100μs
- Задержка p99: <1ms

## Ограничения

1. **Lua скрипты**: Ограниченная поддержка Lua (улучшается)
2. **Модули**: Модули Redis не поддерживаются
3. **Кластер**: Нет режима Redis Cluster (не нужен из-за вертикального масштабирования)
4. **Некоторые команды**: Незначительные различия в некоторых краевых командах

## Лучшие практики

1. **Дайте масштабироваться**: Не ограничивайте одним потоком
2. **Используйте конвейеризацию**: Пакетные операции для лучшей производительности
3. **Лимиты памяти**: Установите подходящий maxmemory
4. **Мониторинг метрик**: Отслеживайте использование памяти и процессора
5. **Персистентность**: Используйте снимки для долговечности

## Устранение неполадок

### Высокое использование памяти
```bash
# Проверка статистики памяти
INFO memory

# Включить режим кэша для автоматического вытеснения
--cache_mode=true
```

### Проблемы с производительностью
```bash
# Проверка количества потоков
INFO server | grep threads

# Мониторинг задержки команд
CLIENT LIST

# Проверка медленных запросов
SLOWLOG GET 10
```

## Ресурсы

- [Веб-сайт Dragonfly](https://dragonflydb.io/)
- [GitHub репозиторий](https://github.com/dragonflydb/dragonfly)
- [Документация](https://www.dragonflydb.io/docs)
- [Бенчмарки производительности](https://www.dragonflydb.io/benchmarks)